import React, { useState, useEffect, useRef, useCallback } from 'react';
import axios from 'axios';
import api from '../Service/Api';
import { Base_url } from '../Service/Base_url';
import './Selectcalander.css';
import {
  ChevronLeft,
  ChevronRight,
  Users,
  CalendarDays,
  Plus,
  Calendar,
  RotateCcw,
  User,
  Check,
  X
} from "lucide-react";
import { Calendar as CalendarIcon } from "lucide-react";


// --- API ENDPOINTS ---
const BOOKING_API_URL = `${Base_url}/bookings`;
const SERVICES_API_URL = `${Base_url}/services`;
const EMPLOYEES_API_URL = `${Base_url}/employees`;
const CLIENTS_API_URL = `${Base_url}/clients`;

// --- HELPER FUNCTIONS ---
const generateTimeSlots = (startTime, endTime, intervalMinutes = 30) => {
  const slots = [];
  let currentHour = parseInt(startTime.split(':')[0]);
  let currentMinute = parseInt(startTime.split(':')[1]);
  const endHour = parseInt(endTime.split(':')[0]);
  const endMinute = parseInt(endTime.split(':')[1]);

  while (currentHour < endHour || (currentHour === endHour && currentMinute <= endMinute)) {
    const hourFormatted = String(currentHour).padStart(2, '0');
    const minuteFormatted = String(currentMinute).padStart(2, '0');
    slots.push(`${hourFormatted}:${minuteFormatted}`);

    currentMinute += intervalMinutes;
    if (currentMinute >= 60) {
      currentHour += Math.floor(currentMinute / 60);
      currentMinute %= 60;
    }
  }
  return slots;
};

const formatTime = (time) => {
  // Return 24-hour format directly
  return time;
};
const formatDateLocal = (d) => {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
};

const getRandomColor = () => {
  const colors = ['#f97316', '#22c55e', '#0ea5e9', '#8b5cf6', '#ec4899', '#ef4444', '#f59e0b', '#10b981'];
  return colors[Math.floor(Math.random() * colors.length)];
};

const getRandomAppointmentColor = () => {
  const colors = ['#f97316', '#22c55e', '#0ea5e9', '#8b5cf6', '#06b6d4', '#ef4444', '#f59e0b'];
  return colors[Math.floor(Math.random() * colors.length)];
};

// Utility function to calculate appointment height based on actual duration
const calculateAppointmentHeight = (startTime, endTime, timeSlotHeight = 80, slotInterval = 30) => {
  const parseHM = (t = '00:00') => {
    if (!t) return 0;
    // Accept "HH:MM", "H:MM", ISO datetime, Date string
    if (t.includes('T') || t.includes('-') || t.endsWith('Z')) {
      const d = new Date(t);
      return d.getHours() * 60 + d.getMinutes();
    }
    const parts = String(t).trim().split(':');
    const h = Number(parts[0] || 0);
    const m = Number(parts[1] || 0);
    return (isNaN(h) ? 0 : h) * 60 + (isNaN(m) ? 0 : m);
  };
  if (!startTime) return Math.round(timeSlotHeight);
  const s = parseHM(startTime);
  let e = endTime ? parseHM(endTime) : s + slotInterval;
  if (e <= s) e = s + slotInterval; // at least one interval

  const durationMinutes = Math.max(1, e - s);
  const heightFloat = (durationMinutes / slotInterval) * timeSlotHeight;
  // use ceil to avoid too-small heights and ensure minimum one slot
  return Math.max(Math.ceil(heightFloat), Math.round(timeSlotHeight));
};

// Utility function to get appointment color based on status
const getAppointmentColorByStatus = (status, defaultColor) => {
  if (!status) return defaultColor;

  const statusLower = status.toLowerCase();

  if (statusLower.includes('confirmed') || statusLower.includes('confirm')) {
    return '#f59e0b'; // Professional yellow for confirmed
  } else if (statusLower.includes('completed') || statusLower.includes('complete')) {
    return '#6b7280'; // Professional grey for completed
  } else {
    return defaultColor; // Keep existing color for other statuses
  }
};

// Helper function to check if an employee has a shift on a specific day
const getDayName = (date) => {
  const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  return days[date.getDay()];
};
const parseShiftsFromSchedule = (schedule) => {
  if (!schedule) return [];

  const pad = (n) => String(n).padStart(2, '0');
  const normalizeHM = (h, m = 0) => `${pad(Number(h))}:${pad(Number(m))}`;

  // try to parse a time token (strings like "09:00", "9", ISO date etc.)
  const parseTimeToken = (token) => {
    if (!token && token !== 0) return null;
    token = String(token).trim();
    // ISO / full datetime -> extract local hours/minutes
    if (token.includes('T') || token.includes('-') || token.includes('/')) {
      const dt = new Date(token);
      if (!isNaN(dt)) return normalizeHM(dt.getHours(), dt.getMinutes());
    }
    // plain "HH:MM" or "H:MM"
    const m1 = token.match(/^(\d{1,2}):(\d{2})$/);
    if (m1) return normalizeHM(m1[1], m1[2]);
    // plain hour like "9" or "09"
    const m2 = token.match(/^(\d{1,2})$/);
    if (m2) return normalizeHM(m2[1], 0);
    return null;
  };

  const pushShift = (s, e) => {
    const start = parseTimeToken(s);
    const end = parseTimeToken(e);
    if (start && end) {
      return { startTime: start, endTime: end };
    }
    return null;
  };

  const result = [];

  // If schedule is a plain string, allow formats like "09:00-17:00,18:00-22:00" or "09-17"
  if (typeof schedule === 'string') {
    const parts = schedule.split(/[;,|]/).map(p => p.trim()).filter(Boolean);
    for (const part of parts) {
      const m = part.match(/(\S+)\s*[-–—]\s*(\S+)/);
      if (m) {
        const s = pushShift(m[1], m[2]);
        if (s) result.push(s);
      }
    }
    return result;
  }

  // If schedule is an array of shifts (strings or objects)
  if (Array.isArray(schedule)) {
    for (const it of schedule) {
      if (!it) continue;
      if (typeof it === 'string') {
        const m = it.match(/(\S+)\s*[-–—]\s*(\S+)/);
        if (m) {
          const s = pushShift(m[1], m[2]);
          if (s) result.push(s);
        }
      } else if (typeof it === 'object') {
        const s = pushShift(it.startTime || it.start, it.endTime || it.end);
        if (s) result.push(s);
      }
    }
    return result;
  }

  // If schedule has common keys: shiftsData, shifts, startTime/endTime
  if (schedule.shiftsData && Array.isArray(schedule.shiftsData)) {
    for (const sh of schedule.shiftsData) {
      const s = pushShift(sh.startTime || sh.start, sh.endTime || sh.end);
      if (s) result.push(s);
    }
  }

  if (schedule.shifts && Array.isArray(schedule.shifts)) {
    for (const sh of schedule.shifts) {
      if (typeof sh === 'string') {
        const m = sh.match(/(\S+)\s*[-–—]\s*(\S+)/);
        if (m) {
          const s = pushShift(m[1], m[2]);
          if (s) result.push(s);
        }
      } else if (typeof sh === 'object') {
        const s = pushShift(sh.startTime || sh.start, sh.endTime || sh.end);
        if (s) result.push(s);
      }
    }
  }

  if (schedule.shifts && typeof schedule.shifts === 'string') {
    const parts = schedule.shifts.split(/[;,|]/).map(p => p.trim()).filter(Boolean);
    for (const part of parts) {
      const m = part.match(/(\S+)\s*[-–—]\s*(\S+)/);
      if (m) {
        const s = pushShift(m[1], m[2]);
        if (s) result.push(s);
      }
    }
  }

  // Single start/end pair
  if ((schedule.startTime || schedule.start) && (schedule.endTime || schedule.end)) {
    const s = pushShift(schedule.startTime || schedule.start, schedule.endTime || schedule.end);
    if (s) result.push(s);
  }

  // Some backends use { periods: [{ from:'09:00', to:'17:00' }] }
  if (schedule.periods && Array.isArray(schedule.periods)) {
    for (const p of schedule.periods) {
      const s = pushShift(p.from || p.start, p.to || p.end);
      if (s) result.push(s);
    }
  }

  // Filter duplicates and invalid
  const unique = [];
  const seen = new Set();
  for (const sh of result) {
    const key = `${sh.startTime}_${sh.endTime}`;
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(sh);
    }
  }

  return unique;
};

const hasShiftOnDate = (employee, date) => {
  if (!employee?.workSchedule) return false;
  const dayName = getDayName(date);
  const schedule = employee.workSchedule[dayName];
  if (!schedule) return false;

  // If explicit boolean flag exists, prefer it
  if (typeof schedule.isWorking === 'boolean') {
    if (schedule.isWorking) return true;
    // if isWorking === false, still check for explicit shift entries (edge cases)
  }

  const parsed = parseShiftsFromSchedule(schedule);
  return parsed.length > 0;
};

// NEW: Get employee's actual shift hours for a specific date
const getEmployeeShiftHours = (employee, date) => {
  if (!employee?.workSchedule) return [];
  const dayName = getDayName(date);
  const schedule = employee.workSchedule[dayName];
  if (!schedule) return [];

  const parsed = parseShiftsFromSchedule(schedule);
  // Normalize times (ensure HH:MM strings)
  return parsed.map(s => ({
    startTime: String(s.startTime).padStart(5, '0'),
    endTime: String(s.endTime).padStart(5, '0')
  })).filter(s => s.startTime && s.endTime);
};
// ENHANCED: Generate time slots ONLY for employee's actual shift hours
const generateTimeSlotsFromEmployeeShift = (employee, date, serviceDuration = 30, intervalMinutes = 30) => {
  // console.log('=== GENERATING TIME SLOTS FROM SHIFT ===');
  // console.log('Employee:', employee?.name);
  // console.log('Service duration:', serviceDuration, 'minutes');
  // console.log('Interval:', intervalMinutes, 'minutes');

  const shifts = getEmployeeShiftHours(employee, date);

  if (shifts.length === 0) {
    // console.log('❌ No shifts found, returning empty slots');
    return [];
  }

  const toMinutes = (timeStr) => {
    const [h, m] = timeStr.split(':').map(Number);
    return h * 60 + (m || 0);
  };

  const minutesToLabel = (mins) => {
    mins = mins % (24 * 60);
    const h = Math.floor(mins / 60).toString().padStart(2, '0');
    const m = (mins % 60).toString().padStart(2, '0');
    return `${h}:${m}`;
  };

  const toISOOnDate = (timeLabel) => {
    const [h, m] = timeLabel.split(':').map(Number);
    const d = new Date(date);
    d.setHours(h, m, 0, 0);
    return d.toISOString();
  };

  const slots = [];

  shifts.forEach(shift => {
    // console.log('Processing shift:', shift.startTime, '-', shift.endTime);

    let startMinutes = toMinutes(shift.startTime);
    let endMinutes = toMinutes(shift.endTime);

    // Handle overnight shifts
    if (endMinutes <= startMinutes) {
      endMinutes += 24 * 60;
    }

    // console.log(`Shift in minutes: ${startMinutes} - ${endMinutes}`);

    // Generate slots for this shift
    for (let slotStart = startMinutes; slotStart + serviceDuration <= endMinutes; slotStart += intervalMinutes) {
      const slotEnd = slotStart + serviceDuration;
      const startLabel = minutesToLabel(slotStart);
      const endLabel = minutesToLabel(slotEnd);

      slots.push({
        startTime: toISOOnDate(startLabel),
        endTime: toISOOnDate(endLabel),
        available: true,
        source: 'employee-shift'
      });
    }
  });

  // console.log('Generated', slots.length, 'time slots from shifts');
  // console.log('Sample slots:', slots.slice(0, 3).map(s => ({
  //   start: new Date(s.startTime).toLocaleTimeString(),
  //   end: new Date(s.endTime).toLocaleTimeString()
  // })));
  // console.log('=====================================');

  return slots;
};

const MOCK_SUCCESS_DATA = {
  employees: [
    { id: 'e1', name: 'Alice', position: 'Stylist', avatar: 'https://i.pravatar.cc/150?img=1', avatarColor: '#f97316', unavailablePeriods: [] },
    { id: 'e2', name: 'Bob', position: 'Barber', avatar: 'https://i.pravatar.cc/150?img=2', avatarColor: '#22c55e', unavailablePeriods: [] },
  ],
  timeSlots: generateTimeSlots('00:00', '23:30', 30),
  appointments: {
    'e1': {
      '2025-08-02_09:00': { client: 'Client A', service: 'Haircut', duration: 30, color: '#f97316' },
    },
    'e2': {
      '2025-08-02_09:30': { client: 'Client C', service: 'Shave', duration: 15, color: '#0ea5e9' },
    }
  },
};

const MOCK_SERVICES_DATA = [
  { _id: 's1', name: 'Haircut', price: 50, duration: 30 },
  { _id: 's2', name: 'Color', price: 150, duration: 60 },
  { _id: 's3', name: 'Deep Cleansing Facial', price: 150, duration: 90 },
  { _id: 's4', name: 'Swedish Massage', price: 150, duration: 60 },
];

const MOCK_CLIENTS_DATA = [
  { _id: 'c1', firstName: 'Aswin', lastName: 'P', email: 'aswinp04@gmail.com', phone: '7736018588' },
  { _id: 'c2', firstName: 'John', lastName: 'Doe', email: 'john.doe@example.com', phone: '123-456-7890' },
];

const MOCK_PROFESSIONALS_DATA = [
  { _id: 'p1', user: { firstName: 'Shaif', lastName: 'Sharif' }, position: 'massage therapist', employeeId: 'shaif_001' },
  { _id: 'p2', user: { firstName: 'Sajad', lastName: 'Yousuf' }, position: 'massage therapist', employeeId: 'sajad_002' },
];

const MOCK_TIME_SLOTS_DATA = [
  { time: '09:00', available: true },
  { time: '09:30', available: true },
  { time: '10:00', available: false },
  { time: '10:30', available: true },
];

const paymentMethods = [
  { value: 'cash', label: 'Cash' },
  { value: 'card', label: 'Card' },
  { value: 'online', label: 'Online' }
];
// Add these functions after your existing date picker functions (around line 400)

// Generate week ranges for a given month
const generateWeekRangesForMonth = (month) => {
  const year = month.getFullYear();
  const monthIndex = month.getMonth();
  
  // Get first day of month
  const firstDay = new Date(year, monthIndex, 1);
  // Get last day of month  
  const lastDay = new Date(year, monthIndex + 1, 0);
  
  const weeks = [];
  let currentWeekStart = new Date(firstDay);
  
  // Start from Monday of the week containing the first day
  while (currentWeekStart.getDay() !== 1) {
    currentWeekStart.setDate(currentWeekStart.getDate() - 1);
  }
  
  let weekNumber = 1;
  
  while (currentWeekStart <= lastDay) {
    const weekEnd = new Date(currentWeekStart);
    weekEnd.setDate(weekEnd.getDate() + 6);
    
    // Check if this week has any days in the current month
    const hasMonthDays = (currentWeekStart <= lastDay && weekEnd >= firstDay);
    
    if (hasMonthDays) {
      weeks.push({
        number: weekNumber,
        startDate: new Date(currentWeekStart),
        endDate: new Date(weekEnd),
        label: `Week ${weekNumber}`,
        dateRange: `${currentWeekStart.getDate()} ${currentWeekStart.toLocaleDateString('en-US', { month: 'short' })} - ${weekEnd.getDate()} ${weekEnd.toLocaleDateString('en-US', { month: 'short' })}`
      });
      weekNumber++;
    }
    
    currentWeekStart.setDate(currentWeekStart.getDate() + 7);
  }
  
  return weeks;
};

// Get current week range based on selected date
const getCurrentWeekRange = (date) => {
  const startOfWeek = new Date(date);
  const day = startOfWeek.getDay();
  const diff = startOfWeek.getDate() - day + (day === 0 ? -6 : 1); // Monday as first day
  startOfWeek.setDate(diff);
  
  const endOfWeek = new Date(startOfWeek);
  endOfWeek.setDate(startOfWeek.getDate() + 6);
  
  return {
    startDate: startOfWeek,
    endDate: endOfWeek,
    label: `Week of ${startOfWeek.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`,
    dateRange: `${startOfWeek.getDate()} - ${endOfWeek.getDate()} ${endOfWeek.toLocaleDateString('en-US', { month: 'short' })}`
  };
};

// Handle week range selection
const handleWeekRangeSelect = (weekRange) => {
  setCurrentDate(weekRange.startDate); // Set to start of selected week
  setSelectedWeekRange(weekRange);
  setShowDatePicker(false);
};

// Handle month selection
const handleMonthSelect = (month, year) => {
  const newDate = new Date(year, month, 1);
  setCurrentDate(newDate);
  setDatePickerCurrentMonth(newDate);
  setShowDatePicker(false);
};

// Navigate months in month-only picker
const goToDatePickerPreviousYear = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear() - 1, prev.getMonth(), 1));
};

const goToDatePickerNextYear = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear() + 1, prev.getMonth(), 1));
};
// --- ENHANCED: Utility to get valid time slots for a professional and service ---
const getValidTimeSlotsForProfessional = (employee, date, serviceDuration, appointments) => {
  const shifts = getEmployeeShiftHours(employee, date);
  if (!shifts.length) return [];

  const intervalMinutes = 10;
  const validSlots = [];

  shifts.forEach(shift => {
    const startMinutes = parseInt(shift.startTime.split(':')[0]) * 60 + parseInt(shift.startTime.split(':')[1]);
    const endMinutes = parseInt(shift.endTime.split(':')[0]) * 60 + parseInt(shift.endTime.split(':')[1]);
    for (let slotStart = startMinutes; slotStart + serviceDuration <= endMinutes; slotStart += intervalMinutes) {
      const hour = Math.floor(slotStart / 60).toString().padStart(2, '0');
      const minute = (slotStart % 60).toString().padStart(2, '0');
      const slotLabel = `${hour}:${minute}`;
      const slotDate = new Date(date);
      slotDate.setHours(hour, minute, 0, 0);
      const slotKey = `${date.toISOString().split('T')[0]}_${slotLabel}`;

      // Check for overlap with existing appointments
      const employeeAppointments = appointments[employee.id] || {};
      const overlaps = Object.entries(employeeAppointments).some(([appKey, app]) => {
        if (!appKey.startsWith(date.toISOString().split('T')[0])) return false;
        const [appHour, appMinute] = appKey.split('_')[1].split(':').map(Number);
        const appStart = new Date(date);
        appStart.setHours(appHour, appMinute, 0, 0);
        const appEnd = new Date(appStart.getTime() + (app.duration || 30) * 60000);
        const slotStartDate = slotDate;
        const slotEndDate = new Date(slotStartDate.getTime() + serviceDuration * 60000);
        return (slotStartDate < appEnd && slotEndDate > appStart);
      });

      if (!overlaps) {
        validSlots.push({
          startTime: slotDate.toISOString(),
          endTime: new Date(slotDate.getTime() + serviceDuration * 60000).toISOString(),
          label: slotLabel,
          available: true
        });
      }
    }
  });

  return validSlots;
};

// --- ENHANCED: Booking Modal Step 2 (Professional Selection) ---
const getAvailableProfessionalsForService = (serviceId, date, employees, appointments, availableServices) => {
  const service = availableServices.find(s => s._id === serviceId);
  if (!service) return [];
  return employees.filter(emp => {
    if (!hasShiftOnDate(emp, date)) return false;
    const validSlots = getValidTimeSlotsForProfessional(emp, date, service.duration, appointments);
    return validSlots.length > 0;
  });
};

// --- ENHANCED: Booking Modal Step 3 (Time Selection) ---
const getAvailableTimeSlotsForProfessional = (employee, date, serviceDuration, appointments) => {
  return getValidTimeSlotsForProfessional(employee, date, serviceDuration, appointments);
};
// Add these helper functions for the date picker (add after the existing helper functions around line 800)
const getDatePickerCalendarDays = (month) => {
  const year = month.getFullYear();
  const monthIndex = month.getMonth();
  
  // First day of the month
  const firstDay = new Date(year, monthIndex, 1);
  // Last day of the month
  const lastDay = new Date(year, monthIndex + 1, 0);
  
  // Calculate padding days needed at the start (Monday = 1, Sunday = 0)
  const startPadding = (firstDay.getDay() + 6) % 7; // Convert to Monday = 0
  
  // Calculate padding days needed at the end
  const totalDays = lastDay.getDate();
  const totalCells = Math.ceil((totalDays + startPadding) / 7) * 7;
  const endPadding = totalCells - (totalDays + startPadding);
  
  const days = [];
  
  // Add padding days from previous month
  for (let i = startPadding; i > 0; i--) {
    const day = new Date(year, monthIndex, 1 - i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  // Add current month days
  for (let day = 1; day <= totalDays; day++) {
    const date = new Date(year, monthIndex, day);
    days.push({ date, isCurrentMonth: true });
  }
  
  // Add padding days from next month
  for (let i = 1; i <= endPadding; i++) {
    const day = new Date(year, monthIndex + 1, i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  return days;
};
const handleDatePickerDateSelect = (date) => {
  setCurrentDate(date);
  setDatePickerSelectedDate(date);
  setShowDatePicker(false);
};

const goToDatePickerPreviousMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() - 1, 1));
};

const goToDatePickerNextMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + 1, 1));
};

const goToDatePickerToday = () => {
  const today = new Date();
  setDatePickerCurrentMonth(today);
  setDatePickerSelectedDate(today);
  setCurrentDate(today);
  setShowDatePicker(false);
};

const SelectCalendar = () => {
  const [datePickerView, setDatePickerView] = useState('date'); // 'date', 'week', 'month'
const [weekRanges, setWeekRanges] = useState([]);
const [selectedWeekRange, setSelectedWeekRange] = useState(null);
  const [employees, setEmployees] = useState([]);
  const [timeSlots, setTimeSlots] = useState([]);
  const [appointments, setAppointments] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [currentView, setCurrentView] = useState('Day');
  const [selectedStaff, setSelectedStaff] = useState('All');
const [showDatePicker, setShowDatePicker] = useState(false);
const [datePickerCurrentMonth, setDatePickerCurrentMonth] = useState(new Date());
const [datePickerSelectedDate, setDatePickerSelectedDate] = useState(new Date());

  // Enhanced Booking Flow States
  const [availableServices, setAvailableServices] = useState([]);
  const [bookingStep, setBookingStep] = useState(1);
  const [showAddBookingModal, setShowAddBookingModal] = useState(false);
  const [showUnavailablePopup, setShowUnavailablePopup] = useState(false);
  const [unavailableMessage, setUnavailableMessage] = useState('');
  const [isNewAppointment, setIsNewAppointment] = useState(false);
  // const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  // Client Search States
  const [existingClients, setExistingClients] = useState([]);
  const [clientSearchQuery, setClientSearchQuery] = useState('');
  const [clientSearchResults, setClientSearchResults] = useState([]);
  const [selectedExistingClient, setSelectedExistingClient] = useState(null);
  const [showClientSearch, setShowClientSearch] = useState(false);
  const [isAddingNewClient, setIsAddingNewClient] = useState(false);

  // Booking Selection States
  const [availableProfessionals, setAvailableProfessionals] = useState([]);
  const [selectedService, setSelectedService] = useState(null);
  const [selectedProfessional, setSelectedProfessional] = useState(null);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [bookingDefaults, setBookingDefaults] = useState(null);

  // Form States
  const [clientInfo, setClientInfo] = useState({ name: '', email: '', phone: '' });
  const [paymentMethod, setPaymentMethod] = useState('cash');
  const [bookingLoading, setBookingLoading] = useState(false);
  const [bookingError, setBookingError] = useState(null);
  const [bookingSuccess, setBookingSuccess] = useState(null);

  // Month View More Appointments States
  const [showMoreAppointments, setShowMoreAppointments] = useState(false);
  const [selectedDayAppointments, setSelectedDayAppointments] = useState([]);
  const [selectedDayDate, setSelectedDayDate] = useState(null);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0 });
  const [dropdownPositionedAbove, setDropdownPositionedAbove] = useState(false);

  // Booking Hover Tooltip States
  const [showBookingTooltip, setShowBookingTooltip] = useState(false);
  const [tooltipData, setTooltipData] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });
  const [showTeamPopup, setShowTeamPopup] = useState(false);
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [teamFilter, setTeamFilter] = useState('all'); // 'all' or 'scheduled'
  const [selectedEmployees, setSelectedEmployees] = useState(new Set());
  const [calendarPopupTab, setCalendarPopupTab] = useState('confirmed');
  // Add these state variables with your existing useState declarations:

const [teamSearchQuery, setTeamSearchQuery] = useState('');
const [teamViewMode, setTeamViewMode] = useState('list'); // 'list' or 'grid'

// Add this helper function:
const getFilteredAndSearchedEmployees = () => {
  let filtered = employees;
  
  // Apply team filter
  if (teamFilter === 'scheduled') {
    filtered = filtered.filter(emp => hasShiftOnDate(emp, currentDate));
  }
  
  // Apply search query
  if (teamSearchQuery.trim()) {
    const query = teamSearchQuery.toLowerCase().trim();
    filtered = filtered.filter(emp => 
      emp.name.toLowerCase().includes(query) ||
      emp.position.toLowerCase().includes(query)
    );
  }
  
  return filtered;
};

// Add this helper function:
const getEmployeeAppointmentCount = (employeeId) => {
  const empAppointments = appointments[employeeId] || {};
  const today = currentDate.toISOString().split('T')[0];
  
  return Object.keys(empAppointments).filter(key => 
    key.startsWith(today)
  ).length;
};

  // Time Slot Hover States
  const [showTimeHover, setShowTimeHover] = useState(false);
  const [hoverTimeData, setHoverTimeData] = useState(null);
  const [hoverTimePosition, setHoverTimePosition] = useState({ top: 0, left: 0 });

  const [bookingForm, setBookingForm] = useState({
    clientName: '',
    clientEmail: '',
    clientPhone: '',
    paymentMethod: 'cash',
    notes: '',
  });

  const schedulerContentRef = useRef(null);

  // Booking Status Management States
  const [showBookingStatusModal, setShowBookingStatusModal] = useState(false);
  const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  const [bookingStatusLoading, setBookingStatusLoading] = useState(false);
  const [bookingStatusError, setBookingStatusError] = useState(null);

  // --- HELPER FUNCTIONS ---
  // const handleTimeSlotClick = (employeeId, slotTime, day) => {
  //   const dayKey = (day || currentDate).toISOString().split('T')[0];
  //   const slotKey = `${dayKey}_${slotTime}`;
  //   const existingAppointment = appointments[employeeId]?.[slotKey];

  //   if (existingAppointment) {
  //     // Show booking status modal for existing appointment
  //     const employee = employees.find(emp => emp.id === employeeId);
  //     const appointmentDetails = {
  //       ...existingAppointment,
  //       employeeId,
  //       employeeName: employee?.name,
  //       slotTime,
  //       date: dayKey,
  //       slotKey
  //     };
  //     setSelectedBookingForStatus(appointmentDetails);
  //     setShowBookingStatusModal(true);
  //     return;
  //   }

  //   // Continue with new booking flow for empty slots
  //   const employee = employees.find(emp => emp.id === employeeId);

  //   // Check if employee has a shift on this day
  //   if (!hasShiftOnDate(employee, day || currentDate)) {
  //     setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
  //   if (unavailableReason && unavailableReason !== "No shift scheduled") {
  //     setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   // Store the clicked employee and time slot as defaults for pre-selection
  //   const staff = employees.find(emp => emp.id === employeeId);
  //   setBookingDefaults({
  //     professional: {
  //       _id: staff.id,
  //       user: {
  //         firstName: staff.name.split(' ')[0],
  //         lastName: staff.name.split(' ').slice(1).join(' ') || ''
  //       }
  //     },
  //     time: slotTime,
  //     staffId: staff.id
  //   });
  //   setIsNewAppointment(true);
  //   setShowAddBookingModal(true);
  // };
  const handleTimeSlotClick = (employeeId, slotTime, day) => {
    // ... (existing logic for checking existing appointments and unavailable periods)
    const dayKey = (day || currentDate).toISOString().split('T')[0];
    const slotKey = `${dayKey}_${slotTime}`;
    const existingAppointment = appointments[employeeId]?.[slotKey];
    console.log('this is the employee id ', employeeId, slotTime)
    if (existingAppointment) {
      // Show booking status modal for existing appointment
      const employee = employees.find(emp => emp.id === employeeId);
      const appointmentDetails = {
        ...existingAppointment,
        employeeId,
        employeeName: employee?.name,
        slotTime,
        date: dayKey,
        slotKey
      };
      setSelectedBookingForStatus(appointmentDetails);
      setShowBookingStatusModal(true);
      return;
    }

    // Continue with new booking flow for empty slots
    const employee = employees.find(emp => emp.id === employeeId);

    // Check if employee has a shift on this day
    if (!hasShiftOnDate(employee, day || currentDate)) {
      setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
      setShowUnavailablePopup(true);
      return;
    }

    const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
    if (unavailableReason && unavailableReason !== "No shift scheduled") {
      setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
      setShowUnavailablePopup(true);
      return;
    }
    // Store the clicked employee and time slot as defaults for pre-selection
    const staff = employees.find(emp => emp.id === employeeId);
    if (!staff) {
      console.error('Employee not found in state for ID:', employeeId);
      return;
    }
    setBookingDefaults({
      professional: staff,
      time: slotTime,
      date: day || currentDate
    });

    setIsNewAppointment(true);
    setShowAddBookingModal(true);
  };

  // ... (inside SelectCalendar component)

  const handleServiceSelect = (service) => {
    setSelectedService(service);
    setBookingStep(2);
    setBookingError(null);

    // Case 1: User clicked a time slot directly
    if (bookingDefaults?.professional) {
      const selectedProfessional = bookingDefaults.professional;
      console.log("selected professional ", selectedProfessional);

      setSelectedProfessional(selectedProfessional);

      const employeeWithSchedule = employees.find(e => e.id === selectedProfessional.id);
      if (employeeWithSchedule) {
        // Correctly generate and filter time slots for the selected professional and service
        const allPossibleSlots = generateTimeSlotsFromEmployeeShift(employeeWithSchedule, bookingDefaults.date, service.duration, 30);
        const filteredSlots = filterOutBookedTimeSlots(allPossibleSlots, selectedProfessional.id, bookingDefaults.date);
        setAvailableTimeSlots(filteredSlots);

        // We have the professional and the time slot already selected from the click.
        // We can skip directly to the client info step.
        const [hour, minute] = bookingDefaults.time.split(':').map(Number);
        const originalSlot = filteredSlots.find(slot => {
          const d = new Date(slot.startTime);
          return d.getHours() === hour && d.getMinutes() === minute;
        });

        if (originalSlot) {
          setSelectedTimeSlot(originalSlot);
          setBookingStep(4); // Skip to client info
        } else {
          setBookingError(`The selected service duration (${service.duration} mins) does not fit in the original time slot. Please choose a different time.`);
          setBookingStep(3); // Stay on time selection, but with a warning.
        }
      } else {
        setBookingError("Professional data is missing. Please try again.");
      }
      return;
    }

    // Case 2: User clicked "Add Appointment" from the header
    const professionals = getAvailableProfessionalsForService(
      service._id,
      currentDate,
      employees,
      appointments,
      availableServices
    );
    setAvailableProfessionals(professionals);
  };

  const closeBookingModal = () => {
    setShowAddBookingModal(false);
    setShowUnavailablePopup(false);
    resetBookingForm();
  };

  const closeBookingStatusModal = () => {
    setShowBookingStatusModal(false);
    setSelectedBookingForStatus(null);
    setBookingStatusError(null);
  };
// Add these functions inside the SelectCalendar component, after your existing functions

const getDatePickerCalendarDays = (month) => {
  const year = month.getFullYear();
  const monthIndex = month.getMonth();
  
  const firstDay = new Date(year, monthIndex, 1);
  const lastDay = new Date(year, monthIndex + 1, 0);
  
  // Calculate padding days needed at the start (Monday = 1, Sunday = 0)
  const startPadding = (firstDay.getDay() + 6) % 7; // Convert to Monday = 0
  
  // Calculate padding days needed at the end
  const totalDays = lastDay.getDate();
  const totalCells = Math.ceil((totalDays + startPadding) / 7) * 7;
  const endPadding = totalCells - (totalDays + startPadding);
  
  const days = [];
  
  // Add padding days from previous month
  for (let i = startPadding; i > 0; i--) {
    const day = new Date(year, monthIndex, 1 - i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  // Add current month days
  for (let day = 1; day <= totalDays; day++) {
    const date = new Date(year, monthIndex, day);
    days.push({ date, isCurrentMonth: true });
  }
  
  // Add padding days from next month
  for (let i = 1; i <= endPadding; i++) {
    const day = new Date(year, monthIndex + 1, i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  return days;
};

const handleDatePickerDateSelect = (date) => {
  setCurrentDate(date);
  setDatePickerSelectedDate(date);
  setShowDatePicker(false);
};

const goToDatePickerPreviousMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() - 1, 1));
};

const goToDatePickerNextMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + 1, 1));
};

const goToDatePickerToday = () => {
  const today = new Date();
  setDatePickerCurrentMonth(today);
  setDatePickerSelectedDate(today);
  setCurrentDate(today);
  setShowDatePicker(false);
};

const SelectCalendar = () => {
  const [datePickerView, setDatePickerView] = useState('date'); // 'date', 'week', 'month'
const [weekRanges, setWeekRanges] = useState([]);
const [selectedWeekRange, setSelectedWeekRange] = useState(null);
  const [employees, setEmployees] = useState([]);
  const [timeSlots, setTimeSlots] = useState([]);
  const [appointments, setAppointments] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [currentView, setCurrentView] = useState('Day');
  const [selectedStaff, setSelectedStaff] = useState('All');
const [showDatePicker, setShowDatePicker] = useState(false);
const [datePickerCurrentMonth, setDatePickerCurrentMonth] = useState(new Date());
const [datePickerSelectedDate, setDatePickerSelectedDate] = useState(new Date());

  // Enhanced Booking Flow States
  const [availableServices, setAvailableServices] = useState([]);
  const [bookingStep, setBookingStep] = useState(1);
  const [showAddBookingModal, setShowAddBookingModal] = useState(false);
  const [showUnavailablePopup, setShowUnavailablePopup] = useState(false);
  const [unavailableMessage, setUnavailableMessage] = useState('');
  const [isNewAppointment, setIsNewAppointment] = useState(false);
  // const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  // Client Search States
  const [existingClients, setExistingClients] = useState([]);
  const [clientSearchQuery, setClientSearchQuery] = useState('');
  const [clientSearchResults, setClientSearchResults] = useState([]);
  const [selectedExistingClient, setSelectedExistingClient] = useState(null);
  const [showClientSearch, setShowClientSearch] = useState(false);
  const [isAddingNewClient, setIsAddingNewClient] = useState(false);

  // Booking Selection States
  const [availableProfessionals, setAvailableProfessionals] = useState([]);
  const [selectedService, setSelectedService] = useState(null);
  const [selectedProfessional, setSelectedProfessional] = useState(null);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [bookingDefaults, setBookingDefaults] = useState(null);

  // Form States
  const [clientInfo, setClientInfo] = useState({ name: '', email: '', phone: '' });
  const [paymentMethod, setPaymentMethod] = useState('cash');
  const [bookingLoading, setBookingLoading] = useState(false);
  const [bookingError, setBookingError] = useState(null);
  const [bookingSuccess, setBookingSuccess] = useState(null);

  // Month View More Appointments States
  const [showMoreAppointments, setShowMoreAppointments] = useState(false);
  const [selectedDayAppointments, setSelectedDayAppointments] = useState([]);
  const [selectedDayDate, setSelectedDayDate] = useState(null);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0 });
  const [dropdownPositionedAbove, setDropdownPositionedAbove] = useState(false);

  // Booking Hover Tooltip States
  const [showBookingTooltip, setShowBookingTooltip] = useState(false);
  const [tooltipData, setTooltipData] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });
  const [showTeamPopup, setShowTeamPopup] = useState(false);
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [teamFilter, setTeamFilter] = useState('all'); // 'all' or 'scheduled'
  const [selectedEmployees, setSelectedEmployees] = useState(new Set());
  const [calendarPopupTab, setCalendarPopupTab] = useState('confirmed');
  // Add these state variables with your existing useState declarations:

const [teamSearchQuery, setTeamSearchQuery] = useState('');
const [teamViewMode, setTeamViewMode] = useState('list'); // 'list' or 'grid'

// Add this helper function:
const getFilteredAndSearchedEmployees = () => {
  let filtered = employees;
  
  // Apply team filter
  if (teamFilter === 'scheduled') {
    filtered = filtered.filter(emp => hasShiftOnDate(emp, currentDate));
  }
  
  // Apply search query
  if (teamSearchQuery.trim()) {
    const query = teamSearchQuery.toLowerCase().trim();
    filtered = filtered.filter(emp => 
      emp.name.toLowerCase().includes(query) ||
      emp.position.toLowerCase().includes(query)
    );
  }
  
  return filtered;
};

// Add this helper function:
const getEmployeeAppointmentCount = (employeeId) => {
  const empAppointments = appointments[employeeId] || {};
  const today = currentDate.toISOString().split('T')[0];
  
  return Object.keys(empAppointments).filter(key => 
    key.startsWith(today)
  ).length;
};

  // Time Slot Hover States
  const [showTimeHover, setShowTimeHover] = useState(false);
  const [hoverTimeData, setHoverTimeData] = useState(null);
  const [hoverTimePosition, setHoverTimePosition] = useState({ top: 0, left: 0 });

  const [bookingForm, setBookingForm] = useState({
    clientName: '',
    clientEmail: '',
    clientPhone: '',
    paymentMethod: 'cash',
    notes: '',
  });

  const schedulerContentRef = useRef(null);

  // Booking Status Management States
  const [showBookingStatusModal, setShowBookingStatusModal] = useState(false);
  const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  const [bookingStatusLoading, setBookingStatusLoading] = useState(false);
  const [bookingStatusError, setBookingStatusError] = useState(null);

  // --- HELPER FUNCTIONS ---
  // const handleTimeSlotClick = (employeeId, slotTime, day) => {
  //   const dayKey = (day || currentDate).toISOString().split('T')[0];
  //   const slotKey = `${dayKey}_${slotTime}`;
  //   const existingAppointment = appointments[employeeId]?.[slotKey];

  //   if (existingAppointment) {
  //     // Show booking status modal for existing appointment
  //     const employee = employees.find(emp => emp.id === employeeId);
  //     const appointmentDetails = {
  //       ...existingAppointment,
  //       employeeId,
  //       employeeName: employee?.name,
  //       slotTime,
  //       date: dayKey,
  //       slotKey
  //     };
  //     setSelectedBookingForStatus(appointmentDetails);
  //     setShowBookingStatusModal(true);
  //     return;
  //   }

  //   // Continue with new booking flow for empty slots
  //   const employee = employees.find(emp => emp.id === employeeId);

  //   // Check if employee has a shift on this day
  //   if (!hasShiftOnDate(employee, day || currentDate)) {
  //     setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
  //   if (unavailableReason && unavailableReason !== "No shift scheduled") {
  //     setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   // Store the clicked employee and time slot as defaults for pre-selection
  //   const staff = employees.find(emp => emp.id === employeeId);
  //   setBookingDefaults({
  //     professional: {
  //       _id: staff.id,
  //       user: {
  //         firstName: staff.name.split(' ')[0],
  //         lastName: staff.name.split(' ').slice(1).join(' ') || ''
  //       }
  //     },
  //     time: slotTime,
  //     staffId: staff.id
  //   });
  //   setIsNewAppointment(true);
  //   setShowAddBookingModal(true);
  // };
  const handleTimeSlotClick = (employeeId, slotTime, day) => {
    // ... (existing logic for checking existing appointments and unavailable periods)
    const dayKey = (day || currentDate).toISOString().split('T')[0];
    const slotKey = `${dayKey}_${slotTime}`;
    const existingAppointment = appointments[employeeId]?.[slotKey];
    console.log('this is the employee id ', employeeId, slotTime)
    if (existingAppointment) {
      // Show booking status modal for existing appointment
      const employee = employees.find(emp => emp.id === employeeId);
      const appointmentDetails = {
        ...existingAppointment,
        employeeId,
        employeeName: employee?.name,
        slotTime,
        date: dayKey,
        slotKey
      };
      setSelectedBookingForStatus(appointmentDetails);
      setShowBookingStatusModal(true);
      return;
    }

    // Continue with new booking flow for empty slots
    const employee = employees.find(emp => emp.id === employeeId);

    // Check if employee has a shift on this day
    if (!hasShiftOnDate(employee, day || currentDate)) {
      setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
      setShowUnavailablePopup(true);
      return;
    }

    const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
    if (unavailableReason && unavailableReason !== "No shift scheduled") {
      setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
      setShowUnavailablePopup(true);
      return;
    }
    // Store the clicked employee and time slot as defaults for pre-selection
    const staff = employees.find(emp => emp.id === employeeId);
    if (!staff) {
      console.error('Employee not found in state for ID:', employeeId);
      return;
    }
    setBookingDefaults({
      professional: staff,
      time: slotTime,
      date: day || currentDate
    });

    setIsNewAppointment(true);
    setShowAddBookingModal(true);
  };

  // ... (inside SelectCalendar component)

  const handleServiceSelect = (service) => {
    setSelectedService(service);
    setBookingStep(2);
    setBookingError(null);

    // Case 1: User clicked a time slot directly
    if (bookingDefaults?.professional) {
      const selectedProfessional = bookingDefaults.professional;
      console.log("selected professional ", selectedProfessional);

      setSelectedProfessional(selectedProfessional);

      const employeeWithSchedule = employees.find(e => e.id === selectedProfessional.id);
      if (employeeWithSchedule) {
        // Correctly generate and filter time slots for the selected professional and service
        const allPossibleSlots = generateTimeSlotsFromEmployeeShift(employeeWithSchedule, bookingDefaults.date, service.duration, 30);
        const filteredSlots = filterOutBookedTimeSlots(allPossibleSlots, selectedProfessional.id, bookingDefaults.date);
        setAvailableTimeSlots(filteredSlots);

        // We have the professional and the time slot already selected from the click.
        // We can skip directly to the client info step.
        const [hour, minute] = bookingDefaults.time.split(':').map(Number);
        const originalSlot = filteredSlots.find(slot => {
          const d = new Date(slot.startTime);
          return d.getHours() === hour && d.getMinutes() === minute;
        });

        if (originalSlot) {
          setSelectedTimeSlot(originalSlot);
          setBookingStep(4); // Skip to client info
        } else {
          setBookingError(`The selected service duration (${service.duration} mins) does not fit in the original time slot. Please choose a different time.`);
          setBookingStep(3); // Stay on time selection, but with a warning.
        }
      } else {
        setBookingError("Professional data is missing. Please try again.");
      }
      return;
    }

    // Case 2: User clicked "Add Appointment" from the header
    const professionals = getAvailableProfessionalsForService(
      service._id,
      currentDate,
      employees,
      appointments,
      availableServices
    );
    setAvailableProfessionals(professionals);
  };

  const closeBookingModal = () => {
    setShowAddBookingModal(false);
    setShowUnavailablePopup(false);
    resetBookingForm();
  };

  const closeBookingStatusModal = () => {
    setShowBookingStatusModal(false);
    setSelectedBookingForStatus(null);
    setBookingStatusError(null);
  };
// Add these functions inside the SelectCalendar component, after your existing functions

const getDatePickerCalendarDays = (month) => {
  const year = month.getFullYear();
  const monthIndex = month.getMonth();
  
  const firstDay = new Date(year, monthIndex, 1);
  const lastDay = new Date(year, monthIndex + 1, 0);
  
  // Calculate padding days needed at the start (Monday = 1, Sunday = 0)
  const startPadding = (firstDay.getDay() + 6) % 7; // Convert to Monday = 0
  
  // Calculate padding days needed at the end
  const totalDays = lastDay.getDate();
  const totalCells = Math.ceil((totalDays + startPadding) / 7) * 7;
  const endPadding = totalCells - (totalDays + startPadding);
  
  const days = [];
  
  // Add padding days from previous month
  for (let i = startPadding; i > 0; i--) {
    const day = new Date(year, monthIndex, 1 - i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  // Add current month days
  for (let day = 1; day <= totalDays; day++) {
    const date = new Date(year, monthIndex, day);
    days.push({ date, isCurrentMonth: true });
  }
  
  // Add padding days from next month
  for (let i = 1; i <= endPadding; i++) {
    const day = new Date(year, monthIndex + 1, i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  return days;
};

const handleDatePickerDateSelect = (date) => {
  setCurrentDate(date);
  setDatePickerSelectedDate(date);
  setShowDatePicker(false);
};

const goToDatePickerPreviousMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() - 1, 1));
};

const goToDatePickerNextMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + 1, 1));
};

const goToDatePickerToday = () => {
  const today = new Date();
  setDatePickerCurrentMonth(today);
  setDatePickerSelectedDate(today);
  setCurrentDate(today);
  setShowDatePicker(false);
};

const SelectCalendar = () => {
  const [datePickerView, setDatePickerView] = useState('date'); // 'date', 'week', 'month'
const [weekRanges, setWeekRanges] = useState([]);
const [selectedWeekRange, setSelectedWeekRange] = useState(null);
  const [employees, setEmployees] = useState([]);
  const [timeSlots, setTimeSlots] = useState([]);
  const [appointments, setAppointments] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [currentView, setCurrentView] = useState('Day');
  const [selectedStaff, setSelectedStaff] = useState('All');
const [showDatePicker, setShowDatePicker] = useState(false);
const [datePickerCurrentMonth, setDatePickerCurrentMonth] = useState(new Date());
const [datePickerSelectedDate, setDatePickerSelectedDate] = useState(new Date());

  // Enhanced Booking Flow States
  const [availableServices, setAvailableServices] = useState([]);
  const [bookingStep, setBookingStep] = useState(1);
  const [showAddBookingModal, setShowAddBookingModal] = useState(false);
  const [showUnavailablePopup, setShowUnavailablePopup] = useState(false);
  const [unavailableMessage, setUnavailableMessage] = useState('');
  const [isNewAppointment, setIsNewAppointment] = useState(false);
  // const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  // Client Search States
  const [existingClients, setExistingClients] = useState([]);
  const [clientSearchQuery, setClientSearchQuery] = useState('');
  const [clientSearchResults, setClientSearchResults] = useState([]);
  const [selectedExistingClient, setSelectedExistingClient] = useState(null);
  const [showClientSearch, setShowClientSearch] = useState(false);
  const [isAddingNewClient, setIsAddingNewClient] = useState(false);

  // Booking Selection States
  const [availableProfessionals, setAvailableProfessionals] = useState([]);
  const [selectedService, setSelectedService] = useState(null);
  const [selectedProfessional, setSelectedProfessional] = useState(null);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [bookingDefaults, setBookingDefaults] = useState(null);

  // Form States
  const [clientInfo, setClientInfo] = useState({ name: '', email: '', phone: '' });
  const [paymentMethod, setPaymentMethod] = useState('cash');
  const [bookingLoading, setBookingLoading] = useState(false);
  const [bookingError, setBookingError] = useState(null);
  const [bookingSuccess, setBookingSuccess] = useState(null);

  // Month View More Appointments States
  const [showMoreAppointments, setShowMoreAppointments] = useState(false);
  const [selectedDayAppointments, setSelectedDayAppointments] = useState([]);
  const [selectedDayDate, setSelectedDayDate] = useState(null);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0 });
  const [dropdownPositionedAbove, setDropdownPositionedAbove] = useState(false);

  // Booking Hover Tooltip States
  const [showBookingTooltip, setShowBookingTooltip] = useState(false);
  const [tooltipData, setTooltipData] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });
  const [showTeamPopup, setShowTeamPopup] = useState(false);
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [teamFilter, setTeamFilter] = useState('all'); // 'all' or 'scheduled'
  const [selectedEmployees, setSelectedEmployees] = useState(new Set());
  const [calendarPopupTab, setCalendarPopupTab] = useState('confirmed');
  // Add these state variables with your existing useState declarations:

const [teamSearchQuery, setTeamSearchQuery] = useState('');
const [teamViewMode, setTeamViewMode] = useState('list'); // 'list' or 'grid'

// Add this helper function:
const getFilteredAndSearchedEmployees = () => {
  let filtered = employees;
  
  // Apply team filter
  if (teamFilter === 'scheduled') {
    filtered = filtered.filter(emp => hasShiftOnDate(emp, currentDate));
  }
  
  // Apply search query
  if (teamSearchQuery.trim()) {
    const query = teamSearchQuery.toLowerCase().trim();
    filtered = filtered.filter(emp => 
      emp.name.toLowerCase().includes(query) ||
      emp.position.toLowerCase().includes(query)
    );
  }
  
  return filtered;
};

// Add this helper function:
const getEmployeeAppointmentCount = (employeeId) => {
  const empAppointments = appointments[employeeId] || {};
  const today = currentDate.toISOString().split('T')[0];
  
  return Object.keys(empAppointments).filter(key => 
    key.startsWith(today)
  ).length;
};

  // Time Slot Hover States
  const [showTimeHover, setShowTimeHover] = useState(false);
  const [hoverTimeData, setHoverTimeData] = useState(null);
  const [hoverTimePosition, setHoverTimePosition] = useState({ top: 0, left: 0 });

  const [bookingForm, setBookingForm] = useState({
    clientName: '',
    clientEmail: '',
    clientPhone: '',
    paymentMethod: 'cash',
    notes: '',
  });

  const schedulerContentRef = useRef(null);

  // Booking Status Management States
  const [showBookingStatusModal, setShowBookingStatusModal] = useState(false);
  const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  const [bookingStatusLoading, setBookingStatusLoading] = useState(false);
  const [bookingStatusError, setBookingStatusError] = useState(null);

  // --- HELPER FUNCTIONS ---
  // const handleTimeSlotClick = (employeeId, slotTime, day) => {
  //   const dayKey = (day || currentDate).toISOString().split('T')[0];
  //   const slotKey = `${dayKey}_${slotTime}`;
  //   const existingAppointment = appointments[employeeId]?.[slotKey];

  //   if (existingAppointment) {
  //     // Show booking status modal for existing appointment
  //     const employee = employees.find(emp => emp.id === employeeId);
  //     const appointmentDetails = {
  //       ...existingAppointment,
  //       employeeId,
  //       employeeName: employee?.name,
  //       slotTime,
  //       date: dayKey,
  //       slotKey
  //     };
  //     setSelectedBookingForStatus(appointmentDetails);
  //     setShowBookingStatusModal(true);
  //     return;
  //   }

  //   // Continue with new booking flow for empty slots
  //   const employee = employees.find(emp => emp.id === employeeId);

  //   // Check if employee has a shift on this day
  //   if (!hasShiftOnDate(employee, day || currentDate)) {
  //     setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
  //   if (unavailableReason && unavailableReason !== "No shift scheduled") {
  //     setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   // Store the clicked employee and time slot as defaults for pre-selection
  //   const staff = employees.find(emp => emp.id === employeeId);
  //   setBookingDefaults({
  //     professional: {
  //       _id: staff.id,
  //       user: {
  //         firstName: staff.name.split(' ')[0],
  //         lastName: staff.name.split(' ').slice(1).join(' ') || ''
  //       }
  //     },
  //     time: slotTime,
  //     staffId: staff.id
  //   });
  //   setIsNewAppointment(true);
  //   setShowAddBookingModal(true);
  // };
  const handleTimeSlotClick = (employeeId, slotTime, day) => {
    // ... (existing logic for checking existing appointments and unavailable periods)
    const dayKey = (day || currentDate).toISOString().split('T')[0];
    const slotKey = `${dayKey}_${slotTime}`;
    const existingAppointment = appointments[employeeId]?.[slotKey];
    console.log('this is the employee id ', employeeId, slotTime)
    if (existingAppointment) {
      // Show booking status modal for existing appointment
      const employee = employees.find(emp => emp.id === employeeId);
      const appointmentDetails = {
        ...existingAppointment,
        employeeId,
        employeeName: employee?.name,
        slotTime,
        date: dayKey,
        slotKey
      };
      setSelectedBookingForStatus(appointmentDetails);
      setShowBookingStatusModal(true);
      return;
    }

    // Continue with new booking flow for empty slots
    const employee = employees.find(emp => emp.id === employeeId);

    // Check if employee has a shift on this day
    if (!hasShiftOnDate(employee, day || currentDate)) {
      setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
      setShowUnavailablePopup(true);
      return;
    }

    const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
    if (unavailableReason && unavailableReason !== "No shift scheduled") {
      setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
      setShowUnavailablePopup(true);
      return;
    }
    // Store the clicked employee and time slot as defaults for pre-selection
    const staff = employees.find(emp => emp.id === employeeId);
    if (!staff) {
      console.error('Employee not found in state for ID:', employeeId);
      return;
    }
    setBookingDefaults({
      professional: staff,
      time: slotTime,
      date: day || currentDate
    });

    setIsNewAppointment(true);
    setShowAddBookingModal(true);
  };

  // ... (inside SelectCalendar component)

  const handleServiceSelect = (service) => {
    setSelectedService(service);
    setBookingStep(2);
    setBookingError(null);

    // Case 1: User clicked a time slot directly
    if (bookingDefaults?.professional) {
      const selectedProfessional = bookingDefaults.professional;
      console.log("selected professional ", selectedProfessional);

      setSelectedProfessional(selectedProfessional);

      const employeeWithSchedule = employees.find(e => e.id === selectedProfessional.id);
      if (employeeWithSchedule) {
        // Correctly generate and filter time slots for the selected professional and service
        const allPossibleSlots = generateTimeSlotsFromEmployeeShift(employeeWithSchedule, bookingDefaults.date, service.duration, 30);
        const filteredSlots = filterOutBookedTimeSlots(allPossibleSlots, selectedProfessional.id, bookingDefaults.date);
        setAvailableTimeSlots(filteredSlots);

        // We have the professional and the time slot already selected from the click.
        // We can skip directly to the client info step.
        const [hour, minute] = bookingDefaults.time.split(':').map(Number);
        const originalSlot = filteredSlots.find(slot => {
          const d = new Date(slot.startTime);
          return d.getHours() === hour && d.getMinutes() === minute;
        });

        if (originalSlot) {
          setSelectedTimeSlot(originalSlot);
          setBookingStep(4); // Skip to client info
        } else {
          setBookingError(`The selected service duration (${service.duration} mins) does not fit in the original time slot. Please choose a different time.`);
          setBookingStep(3); // Stay on time selection, but with a warning.
        }
      } else {
        setBookingError("Professional data is missing. Please try again.");
      }
      return;
    }

    // Case 2: User clicked "Add Appointment" from the header
    const professionals = getAvailableProfessionalsForService(
      service._id,
      currentDate,
      employees,
      appointments,
      availableServices
    );
    setAvailableProfessionals(professionals);
  };

  const closeBookingModal = () => {
    setShowAddBookingModal(false);
    setShowUnavailablePopup(false);
    resetBookingForm();
  };

  const closeBookingStatusModal = () => {
    setShowBookingStatusModal(false);
    setSelectedBookingForStatus(null);
    setBookingStatusError(null);
  };
// Add these functions inside the SelectCalendar component, after your existing functions

const getDatePickerCalendarDays = (month) => {
  const year = month.getFullYear();
  const monthIndex = month.getMonth();
  
  const firstDay = new Date(year, monthIndex, 1);
  const lastDay = new Date(year, monthIndex + 1, 0);
  
  // Calculate padding days needed at the start (Monday = 1, Sunday = 0)
  const startPadding = (firstDay.getDay() + 6) % 7; // Convert to Monday = 0
  
  // Calculate padding days needed at the end
  const totalDays = lastDay.getDate();
  const totalCells = Math.ceil((totalDays + startPadding) / 7) * 7;
  const endPadding = totalCells - (totalDays + startPadding);
  
  const days = [];
  
  // Add padding days from previous month
  for (let i = startPadding; i > 0; i--) {
    const day = new Date(year, monthIndex, 1 - i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  // Add current month days
  for (let day = 1; day <= totalDays; day++) {
    const date = new Date(year, monthIndex, day);
    days.push({ date, isCurrentMonth: true });
  }
  
  // Add padding days from next month
  for (let i = 1; i <= endPadding; i++) {
    const day = new Date(year, monthIndex + 1, i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  return days;
};

const handleDatePickerDateSelect = (date) => {
  setCurrentDate(date);
  setDatePickerSelectedDate(date);
  setShowDatePicker(false);
};

const goToDatePickerPreviousMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() - 1, 1));
};

const goToDatePickerNextMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + 1, 1));
};

const goToDatePickerToday = () => {
  const today = new Date();
  setDatePickerCurrentMonth(today);
  setDatePickerSelectedDate(today);
  setCurrentDate(today);
  setShowDatePicker(false);
};

const SelectCalendar = () => {
  const [datePickerView, setDatePickerView] = useState('date'); // 'date', 'week', 'month'
const [weekRanges, setWeekRanges] = useState([]);
const [selectedWeekRange, setSelectedWeekRange] = useState(null);
  const [employees, setEmployees] = useState([]);
  const [timeSlots, setTimeSlots] = useState([]);
  const [appointments, setAppointments] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [currentView, setCurrentView] = useState('Day');
  const [selectedStaff, setSelectedStaff] = useState('All');
const [showDatePicker, setShowDatePicker] = useState(false);
const [datePickerCurrentMonth, setDatePickerCurrentMonth] = useState(new Date());
const [datePickerSelectedDate, setDatePickerSelectedDate] = useState(new Date());

  // Enhanced Booking Flow States
  const [availableServices, setAvailableServices] = useState([]);
  const [bookingStep, setBookingStep] = useState(1);
  const [showAddBookingModal, setShowAddBookingModal] = useState(false);
  const [showUnavailablePopup, setShowUnavailablePopup] = useState(false);
  const [unavailableMessage, setUnavailableMessage] = useState('');
  const [isNewAppointment, setIsNewAppointment] = useState(false);
  // const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  // Client Search States
  const [existingClients, setExistingClients] = useState([]);
  const [clientSearchQuery, setClientSearchQuery] = useState('');
  const [clientSearchResults, setClientSearchResults] = useState([]);
  const [selectedExistingClient, setSelectedExistingClient] = useState(null);
  const [showClientSearch, setShowClientSearch] = useState(false);
  const [isAddingNewClient, setIsAddingNewClient] = useState(false);

  // Booking Selection States
  const [availableProfessionals, setAvailableProfessionals] = useState([]);
  const [selectedService, setSelectedService] = useState(null);
  const [selectedProfessional, setSelectedProfessional] = useState(null);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [bookingDefaults, setBookingDefaults] = useState(null);

  // Form States
  const [clientInfo, setClientInfo] = useState({ name: '', email: '', phone: '' });
  const [paymentMethod, setPaymentMethod] = useState('cash');
  const [bookingLoading, setBookingLoading] = useState(false);
  const [bookingError, setBookingError] = useState(null);
  const [bookingSuccess, setBookingSuccess] = useState(null);

  // Month View More Appointments States
  const [showMoreAppointments, setShowMoreAppointments] = useState(false);
  const [selectedDayAppointments, setSelectedDayAppointments] = useState([]);
  const [selectedDayDate, setSelectedDayDate] = useState(null);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0 });
  const [dropdownPositionedAbove, setDropdownPositionedAbove] = useState(false);

  // Booking Hover Tooltip States
  const [showBookingTooltip, setShowBookingTooltip] = useState(false);
  const [tooltipData, setTooltipData] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });
  const [showTeamPopup, setShowTeamPopup] = useState(false);
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [teamFilter, setTeamFilter] = useState('all'); // 'all' or 'scheduled'
  const [selectedEmployees, setSelectedEmployees] = useState(new Set());
  const [calendarPopupTab, setCalendarPopupTab] = useState('confirmed');
  // Add these state variables with your existing useState declarations:

const [teamSearchQuery, setTeamSearchQuery] = useState('');
const [teamViewMode, setTeamViewMode] = useState('list'); // 'list' or 'grid'

// Add this helper function:
const getFilteredAndSearchedEmployees = () => {
  let filtered = employees;
  
  // Apply team filter
  if (teamFilter === 'scheduled') {
    filtered = filtered.filter(emp => hasShiftOnDate(emp, currentDate));
  }
  
  // Apply search query
  if (teamSearchQuery.trim()) {
    const query = teamSearchQuery.toLowerCase().trim();
    filtered = filtered.filter(emp => 
      emp.name.toLowerCase().includes(query) ||
      emp.position.toLowerCase().includes(query)
    );
  }
  
  return filtered;
};

// Add this helper function:
const getEmployeeAppointmentCount = (employeeId) => {
  const empAppointments = appointments[employeeId] || {};
  const today = currentDate.toISOString().split('T')[0];
  
  return Object.keys(empAppointments).filter(key => 
    key.startsWith(today)
  ).length;
};

  // Time Slot Hover States
  const [showTimeHover, setShowTimeHover] = useState(false);
  const [hoverTimeData, setHoverTimeData] = useState(null);
  const [hoverTimePosition, setHoverTimePosition] = useState({ top: 0, left: 0 });

  const [bookingForm, setBookingForm] = useState({
    clientName: '',
    clientEmail: '',
    clientPhone: '',
    paymentMethod: 'cash',
    notes: '',
  });

  const schedulerContentRef = useRef(null);

  // Booking Status Management States
  const [showBookingStatusModal, setShowBookingStatusModal] = useState(false);
  const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  const [bookingStatusLoading, setBookingStatusLoading] = useState(false);
  const [bookingStatusError, setBookingStatusError] = useState(null);

  // --- HELPER FUNCTIONS ---
  // const handleTimeSlotClick = (employeeId, slotTime, day) => {
  //   const dayKey = (day || currentDate).toISOString().split('T')[0];
  //   const slotKey = `${dayKey}_${slotTime}`;
  //   const existingAppointment = appointments[employeeId]?.[slotKey];

  //   if (existingAppointment) {
  //     // Show booking status modal for existing appointment
  //     const employee = employees.find(emp => emp.id === employeeId);
  //     const appointmentDetails = {
  //       ...existingAppointment,
  //       employeeId,
  //       employeeName: employee?.name,
  //       slotTime,
  //       date: dayKey,
  //       slotKey
  //     };
  //     setSelectedBookingForStatus(appointmentDetails);
  //     setShowBookingStatusModal(true);
  //     return;
  //   }

  //   // Continue with new booking flow for empty slots
  //   const employee = employees.find(emp => emp.id === employeeId);

  //   // Check if employee has a shift on this day
  //   if (!hasShiftOnDate(employee, day || currentDate)) {
  //     setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
  //   if (unavailableReason && unavailableReason !== "No shift scheduled") {
  //     setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   // Store the clicked employee and time slot as defaults for pre-selection
  //   const staff = employees.find(emp => emp.id === employeeId);
  //   setBookingDefaults({
  //     professional: {
  //       _id: staff.id,
  //       user: {
  //         firstName: staff.name.split(' ')[0],
  //         lastName: staff.name.split(' ').slice(1).join(' ') || ''
  //       }
  //     },
  //     time: slotTime,
  //     staffId: staff.id
  //   });
  //   setIsNewAppointment(true);
  //   setShowAddBookingModal(true);
  // };
  const handleTimeSlotClick = (employeeId, slotTime, day) => {
    // ... (existing logic for checking existing appointments and unavailable periods)
    const dayKey = (day || currentDate).toISOString().split('T')[0];
    const slotKey = `${dayKey}_${slotTime}`;
    const existingAppointment = appointments[employeeId]?.[slotKey];
    console.log('this is the employee id ', employeeId, slotTime)
    if (existingAppointment) {
      // Show booking status modal for existing appointment
      const employee = employees.find(emp => emp.id === employeeId);
      const appointmentDetails = {
        ...existingAppointment,
        employeeId,
        employeeName: employee?.name,
        slotTime,
        date: dayKey,
        slotKey
      };
      setSelectedBookingForStatus(appointmentDetails);
      setShowBookingStatusModal(true);
      return;
    }

    // Continue with new booking flow for empty slots
    const employee = employees.find(emp => emp.id === employeeId);

    // Check if employee has a shift on this day
    if (!hasShiftOnDate(employee, day || currentDate)) {
      setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
      setShowUnavailablePopup(true);
      return;
    }

    const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
    if (unavailableReason && unavailableReason !== "No shift scheduled") {
      setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
      setShowUnavailablePopup(true);
      return;
    }
    // Store the clicked employee and time slot as defaults for pre-selection
    const staff = employees.find(emp => emp.id === employeeId);
    if (!staff) {
      console.error('Employee not found in state for ID:', employeeId);
      return;
    }
    setBookingDefaults({
      professional: staff,
      time: slotTime,
      date: day || currentDate
    });

    setIsNewAppointment(true);
    setShowAddBookingModal(true);
  };

  // ... (inside SelectCalendar component)

  const handleServiceSelect = (service) => {
    setSelectedService(service);
    setBookingStep(2);
    setBookingError(null);

    // Case 1: User clicked a time slot directly
    if (bookingDefaults?.professional) {
      const selectedProfessional = bookingDefaults.professional;
      console.log("selected professional ", selectedProfessional);

      setSelectedProfessional(selectedProfessional);

      const employeeWithSchedule = employees.find(e => e.id === selectedProfessional.id);
      if (employeeWithSchedule) {
        // Correctly generate and filter time slots for the selected professional and service
        const allPossibleSlots = generateTimeSlotsFromEmployeeShift(employeeWithSchedule, bookingDefaults.date, service.duration, 30);
        const filteredSlots = filterOutBookedTimeSlots(allPossibleSlots, selectedProfessional.id, bookingDefaults.date);
        setAvailableTimeSlots(filteredSlots);

        // We have the professional and the time slot already selected from the click.
        // We can skip directly to the client info step.
        const [hour, minute] = bookingDefaults.time.split(':').map(Number);
        const originalSlot = filteredSlots.find(slot => {
          const d = new Date(slot.startTime);
          return d.getHours() === hour && d.getMinutes() === minute;
        });

        if (originalSlot) {
          setSelectedTimeSlot(originalSlot);
          setBookingStep(4); // Skip to client info
        } else {
          setBookingError(`The selected service duration (${service.duration} mins) does not fit in the original time slot. Please choose a different time.`);
          setBookingStep(3); // Stay on time selection, but with a warning.
        }
      } else {
        setBookingError("Professional data is missing. Please try again.");
      }
      return;
    }

    // Case 2: User clicked "Add Appointment" from the header
    const professionals = getAvailableProfessionalsForService(
      service._id,
      currentDate,
      employees,
      appointments,
      availableServices
    );
    setAvailableProfessionals(professionals);
  };

  const closeBookingModal = () => {
    setShowAddBookingModal(false);
    setShowUnavailablePopup(false);
    resetBookingForm();
  };

  const closeBookingStatusModal = () => {
    setShowBookingStatusModal(false);
    setSelectedBookingForStatus(null);
    setBookingStatusError(null);
  };
// Add these functions inside the SelectCalendar component, after your existing functions

const getDatePickerCalendarDays = (month) => {
  const year = month.getFullYear();
  const monthIndex = month.getMonth();
  
  const firstDay = new Date(year, monthIndex, 1);
  const lastDay = new Date(year, monthIndex + 1, 0);
  
  // Calculate padding days needed at the start (Monday = 1, Sunday = 0)
  const startPadding = (firstDay.getDay() + 6) % 7; // Convert to Monday = 0
  
  // Calculate padding days needed at the end
  const totalDays = lastDay.getDate();
  const totalCells = Math.ceil((totalDays + startPadding) / 7) * 7;
  const endPadding = totalCells - (totalDays + startPadding);
  
  const days = [];
  
  // Add padding days from previous month
  for (let i = startPadding; i > 0; i--) {
    const day = new Date(year, monthIndex, 1 - i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  // Add current month days
  for (let day = 1; day <= totalDays; day++) {
    const date = new Date(year, monthIndex, day);
    days.push({ date, isCurrentMonth: true });
  }
  
  // Add padding days from next month
  for (let i = 1; i <= endPadding; i++) {
    const day = new Date(year, monthIndex + 1, i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  return days;
};

const handleDatePickerDateSelect = (date) => {
  setCurrentDate(date);
  setDatePickerSelectedDate(date);
  setShowDatePicker(false);
};

const goToDatePickerPreviousMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() - 1, 1));
};

const goToDatePickerNextMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + 1, 1));
};

const goToDatePickerToday = () => {
  const today = new Date();
  setDatePickerCurrentMonth(today);
  setDatePickerSelectedDate(today);
  setCurrentDate(today);
  setShowDatePicker(false);
};

const SelectCalendar = () => {
  const [datePickerView, setDatePickerView] = useState('date'); // 'date', 'week', 'month'
const [weekRanges, setWeekRanges] = useState([]);
const [selectedWeekRange, setSelectedWeekRange] = useState(null);
  const [employees, setEmployees] = useState([]);
  const [timeSlots, setTimeSlots] = useState([]);
  const [appointments, setAppointments] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [currentView, setCurrentView] = useState('Day');
  const [selectedStaff, setSelectedStaff] = useState('All');
const [showDatePicker, setShowDatePicker] = useState(false);
const [datePickerCurrentMonth, setDatePickerCurrentMonth] = useState(new Date());
const [datePickerSelectedDate, setDatePickerSelectedDate] = useState(new Date());

  // Enhanced Booking Flow States
  const [availableServices, setAvailableServices] = useState([]);
  const [bookingStep, setBookingStep] = useState(1);
  const [showAddBookingModal, setShowAddBookingModal] = useState(false);
  const [showUnavailablePopup, setShowUnavailablePopup] = useState(false);
  const [unavailableMessage, setUnavailableMessage] = useState('');
  const [isNewAppointment, setIsNewAppointment] = useState(false);
  // const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  // Client Search States
  const [existingClients, setExistingClients] = useState([]);
  const [clientSearchQuery, setClientSearchQuery] = useState('');
  const [clientSearchResults, setClientSearchResults] = useState([]);
  const [selectedExistingClient, setSelectedExistingClient] = useState(null);
  const [showClientSearch, setShowClientSearch] = useState(false);
  const [isAddingNewClient, setIsAddingNewClient] = useState(false);

  // Booking Selection States
  const [availableProfessionals, setAvailableProfessionals] = useState([]);
  const [selectedService, setSelectedService] = useState(null);
  const [selectedProfessional, setSelectedProfessional] = useState(null);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [bookingDefaults, setBookingDefaults] = useState(null);

  // Form States
  const [clientInfo, setClientInfo] = useState({ name: '', email: '', phone: '' });
  const [paymentMethod, setPaymentMethod] = useState('cash');
  const [bookingLoading, setBookingLoading] = useState(false);
  const [bookingError, setBookingError] = useState(null);
  const [bookingSuccess, setBookingSuccess] = useState(null);

  // Month View More Appointments States
  const [showMoreAppointments, setShowMoreAppointments] = useState(false);
  const [selectedDayAppointments, setSelectedDayAppointments] = useState([]);
  const [selectedDayDate, setSelectedDayDate] = useState(null);
  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0 });
  const [dropdownPositionedAbove, setDropdownPositionedAbove] = useState(false);

  // Booking Hover Tooltip States
  const [showBookingTooltip, setShowBookingTooltip] = useState(false);
  const [tooltipData, setTooltipData] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });
  const [showTeamPopup, setShowTeamPopup] = useState(false);
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [teamFilter, setTeamFilter] = useState('all'); // 'all' or 'scheduled'
  const [selectedEmployees, setSelectedEmployees] = useState(new Set());
  const [calendarPopupTab, setCalendarPopupTab] = useState('confirmed');
  // Add these state variables with your existing useState declarations:

const [teamSearchQuery, setTeamSearchQuery] = useState('');
const [teamViewMode, setTeamViewMode] = useState('list'); // 'list' or 'grid'

// Add this helper function:
const getFilteredAndSearchedEmployees = () => {
  let filtered = employees;
  
  // Apply team filter
  if (teamFilter === 'scheduled') {
    filtered = filtered.filter(emp => hasShiftOnDate(emp, currentDate));
  }
  
  // Apply search query
  if (teamSearchQuery.trim()) {
    const query = teamSearchQuery.toLowerCase().trim();
    filtered = filtered.filter(emp => 
      emp.name.toLowerCase().includes(query) ||
      emp.position.toLowerCase().includes(query)
    );
  }
  
  return filtered;
};

// Add this helper function:
const getEmployeeAppointmentCount = (employeeId) => {
  const empAppointments = appointments[employeeId] || {};
  const today = currentDate.toISOString().split('T')[0];
  
  return Object.keys(empAppointments).filter(key => 
    key.startsWith(today)
  ).length;
};

  // Time Slot Hover States
  const [showTimeHover, setShowTimeHover] = useState(false);
  const [hoverTimeData, setHoverTimeData] = useState(null);
  const [hoverTimePosition, setHoverTimePosition] = useState({ top: 0, left: 0 });

  const [bookingForm, setBookingForm] = useState({
    clientName: '',
    clientEmail: '',
    clientPhone: '',
    paymentMethod: 'cash',
    notes: '',
  });

  const schedulerContentRef = useRef(null);

  // Booking Status Management States
  const [showBookingStatusModal, setShowBookingStatusModal] = useState(false);
  const [selectedBookingForStatus, setSelectedBookingForStatus] = useState(null);
  const [bookingStatusLoading, setBookingStatusLoading] = useState(false);
  const [bookingStatusError, setBookingStatusError] = useState(null);

  // --- HELPER FUNCTIONS ---
  // const handleTimeSlotClick = (employeeId, slotTime, day) => {
  //   const dayKey = (day || currentDate).toISOString().split('T')[0];
  //   const slotKey = `${dayKey}_${slotTime}`;
  //   const existingAppointment = appointments[employeeId]?.[slotKey];

  //   if (existingAppointment) {
  //     // Show booking status modal for existing appointment
  //     const employee = employees.find(emp => emp.id === employeeId);
  //     const appointmentDetails = {
  //       ...existingAppointment,
  //       employeeId,
  //       employeeName: employee?.name,
  //       slotTime,
  //       date: dayKey,
  //       slotKey
  //     };
  //     setSelectedBookingForStatus(appointmentDetails);
  //     setShowBookingStatusModal(true);
  //     return;
  //   }

  //   // Continue with new booking flow for empty slots
  //   const employee = employees.find(emp => emp.id === employeeId);

  //   // Check if employee has a shift on this day
  //   if (!hasShiftOnDate(employee, day || currentDate)) {
  //     setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
  //   if (unavailableReason && unavailableReason !== "No shift scheduled") {
  //     setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
  //     setShowUnavailablePopup(true);
  //     return;
  //   }

  //   // Store the clicked employee and time slot as defaults for pre-selection
  //   const staff = employees.find(emp => emp.id === employeeId);
  //   setBookingDefaults({
  //     professional: {
  //       _id: staff.id,
  //       user: {
  //         firstName: staff.name.split(' ')[0],
  //         lastName: staff.name.split(' ').slice(1).join(' ') || ''
  //       }
  //     },
  //     time: slotTime,
  //     staffId: staff.id
  //   });
  //   setIsNewAppointment(true);
  //   setShowAddBookingModal(true);
  // };
  const handleTimeSlotClick = (employeeId, slotTime, day) => {
    // ... (existing logic for checking existing appointments and unavailable periods)
    const dayKey = (day || currentDate).toISOString().split('T')[0];
    const slotKey = `${dayKey}_${slotTime}`;
    const existingAppointment = appointments[employeeId]?.[slotKey];
    console.log('this is the employee id ', employeeId, slotTime)
    if (existingAppointment) {
      // Show booking status modal for existing appointment
      const employee = employees.find(emp => emp.id === employeeId);
      const appointmentDetails = {
        ...existingAppointment,
        employeeId,
        employeeName: employee?.name,
        slotTime,
        date: dayKey,
        slotKey
      };
      setSelectedBookingForStatus(appointmentDetails);
      setShowBookingStatusModal(true);
      return;
    }

    // Continue with new booking flow for empty slots
    const employee = employees.find(emp => emp.id === employeeId);

    // Check if employee has a shift on this day
    if (!hasShiftOnDate(employee, day || currentDate)) {
      setUnavailableMessage(`${employee?.name || 'Employee'} has no shift scheduled on this day`);
      setShowUnavailablePopup(true);
      return;
    }

    const unavailableReason = isTimeSlotUnavailable(employeeId, slotTime);
    if (unavailableReason && unavailableReason !== "No shift scheduled") {
      setUnavailableMessage(`This time slot is unavailable: ${unavailableReason}`);
      setShowUnavailablePopup(true);
      return;
    }
    // Store the clicked employee and time slot as defaults for pre-selection
    const staff = employees.find(emp => emp.id === employeeId);
    if (!staff) {
      console.error('Employee not found in state for ID:', employeeId);
      return;
    }
    setBookingDefaults({
      professional: staff,
      time: slotTime,
      date: day || currentDate
    });

    setIsNewAppointment(true);
    setShowAddBookingModal(true);
  };

  // ... (inside SelectCalendar component)

  const handleServiceSelect = (service) => {
    setSelectedService(service);
    setBookingStep(2);
    setBookingError(null);

    // Case 1: User clicked a time slot directly
    if (bookingDefaults?.professional) {
      const selectedProfessional = bookingDefaults.professional;
      console.log("selected professional ", selectedProfessional);

      setSelectedProfessional(selectedProfessional);

      const employeeWithSchedule = employees.find(e => e.id === selectedProfessional.id);
      if (employeeWithSchedule) {
        // Correctly generate and filter time slots for the selected professional and service
        const allPossibleSlots = generateTimeSlotsFromEmployeeShift(employeeWithSchedule, bookingDefaults.date, service.duration, 30);
        const filteredSlots = filterOutBookedTimeSlots(allPossibleSlots, selectedProfessional.id, bookingDefaults.date);
        setAvailableTimeSlots(filteredSlots);

        // We have the professional and the time slot already selected from the click.
        // We can skip directly to the client info step.
        const [hour, minute] = bookingDefaults.time.split(':').map(Number);
        const originalSlot = filteredSlots.find(slot => {
          const d = new Date(slot.startTime);
          return d.getHours() === hour && d.getMinutes() === minute;
        });

        if (originalSlot) {
          setSelectedTimeSlot(originalSlot);
          setBookingStep(4); // Skip to client info
        } else {
          setBookingError(`The selected service duration (${service.duration} mins) does not fit in the original time slot. Please choose a different time.`);
          setBookingStep(3); // Stay on time selection, but with a warning.
        }
      } else {
        setBookingError("Professional data is missing. Please try again.");
      }
      return;
    }

    // Case 2: User clicked "Add Appointment" from the header
    const professionals = getAvailableProfessionalsForService(
      service._id,
      currentDate,
      employees,
      appointments,
      availableServices
    );
    setAvailableProfessionals(professionals);
  };

  const closeBookingModal = () => {
    setShowAddBookingModal(false);
    setShowUnavailablePopup(false);
    resetBookingForm();
  };

  const closeBookingStatusModal = () => {
    setShowBookingStatusModal(false);
    setSelectedBookingForStatus(null);
    setBookingStatusError(null);
  };
// Add these functions inside the SelectCalendar component, after your existing functions

const getDatePickerCalendarDays = (month) => {
  const year = month.getFullYear();
  const monthIndex = month.getMonth();
  
  const firstDay = new Date(year, monthIndex, 1);
  const lastDay = new Date(year, monthIndex + 1, 0);
  
  // Calculate padding days needed at the start (Monday = 1, Sunday = 0)
  const startPadding = (firstDay.getDay() + 6) % 7; // Convert to Monday = 0
  
  // Calculate padding days needed at the end
  const totalDays = lastDay.getDate();
  const totalCells = Math.ceil((totalDays + startPadding) / 7) * 7;
  const endPadding = totalCells - (totalDays + startPadding);
  
  const days = [];
  
  // Add padding days from previous month
  for (let i = startPadding; i > 0; i--) {
    const day = new Date(year, monthIndex, 1 - i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  // Add current month days
  for (let day = 1; day <= totalDays; day++) {
    const date = new Date(year, monthIndex, day);
    days.push({ date, isCurrentMonth: true });
  }
  
  // Add padding days from next month
  for (let i = 1; i <= endPadding; i++) {
    const day = new Date(year, monthIndex + 1, i);
    days.push({ date: day, isCurrentMonth: false });
  }
  
  return days;
};

const handleDatePickerDateSelect = (date) => {
  setCurrentDate(date);
  setDatePickerSelectedDate(date);
  setShowDatePicker(false);
};

const goToDatePickerPreviousMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() - 1, 1));
};

const goToDatePickerNextMonth = () => {
  setDatePickerCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + 1, 1));
};

const goToDatePickerToday = () => {
  const today = new Date();
  setDatePickerCurrentMonth(today);
  setDatePickerSelectedDate(today);
  setCurrentDate(today);
  setShowDatePicker(false);
};

// Replace the StaffColumn component with this improved minute-accurate version
const StaffColumn = ({
  employee,
  timeSlots,
  appointments,
  currentDate,
  isTimeSlotUnavailable,
  handleTimeSlotClick,
  showBookingTooltipHandler,
  hideBookingTooltip,
  showTimeHoverHandler,
  hideTimeHover,
  setSelectedBookingForStatus,
  setShowBookingStatusModal
}) => {
  const timeSlotHeightPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--time-slot-height')) || 20;
  const slotInterval = 30; // grid interval in minutes (visual rows)
  const dayKey = currentDate.toISOString().split('T')[0];
  const hasShift = hasShiftOnDate(employee, currentDate);
  const shiftHours = getEmployeeShiftHours(employee, currentDate);
  const hasValidShifts = shiftHours.length > 0;

  // Build appointment blocks (minute-accurate top/height)
  const appointmentBlocks = [];
  const appointmentRanges = []; // store minute ranges for overlap tests

  const employeeAppointments = appointments[employee.id] || {};
  const firstVisibleSlot = (timeSlots && timeSlots.length) ? timeSlots[0] : '00:00';

  Object.entries(employeeAppointments).forEach(([slotKey, appointment]) => {
    if (!slotKey.startsWith(dayKey)) return;
    if (!appointment.isMainSlot) return;

    // parse start and end minutes using available ISO or label
    const parseToMinutes = (t) => {
      if (!t) return null;
      if (typeof t !== 'string') return null;
      if (t.includes('T') || t.includes('-') || t.endsWith('Z')) {
        const d = new Date(t);
        if (isNaN(d)) return null;
        return d.getHours() * 60 + d.getMinutes();
      }
      const [hh = '0', mm = '0'] = t.split(':');
      return (Number(hh) || 0) * 60 + (Number(mm) || 0);
    };

    const startM = parseToMinutes(appointment.startISO || appointment.startTime) ?? parseToMinutes(appointment.startTime) ?? 0;
    let endM = parseToMinutes(appointment.endISO || appointment.endTime) ?? null;
    if (!endM) {
      endM = startM + (Number(appointment.duration) || slotInterval);
    }
    if (endM <= startM) endM = startM + (Number(appointment.duration) || slotInterval);

    // compute top/height relative to firstVisibleSlot
    const refM = parseToMinutes(firstVisibleSlot) ?? 0;
    const topPx = Math.max(0, ((startM - refM) / slotInterval) * timeSlotHeightPx);
    const heightPx = Math.max(Math.ceil(((endM - startM) / slotInterval) * timeSlotHeightPx), Math.round(timeSlotHeightPx));

    appointmentBlocks.push({
      startM,
      endM,
      topPx,
      heightPx,
      appointment: { ...appointment }
    });

    appointmentRanges.push({ startM, endM });
  });

  // helper to check minute-overlap between a slot and any appointment range
  const slotIsOverlapped = (slotStartMin, slotEndMin) => {
    return appointmentRanges.some(r => !(slotEndMin <= r.startM || slotStartMin >= r.endM));
  };

  return (
    <div key={employee.id} className={`staff-column ${!hasShift ? 'staff-absent' : ''} ${!hasValidShifts ? 'no-shifts' : ''}`}>
      <div className="staff-header">
        <div className="staff-avatar" style={{
          backgroundColor: hasShift && hasValidShifts ? employee.avatarColor : '#9ca3af',
          opacity: hasShift && hasValidShifts ? 1 : 0.5
        }}>
          {employee.avatar ? <img src={employee.avatar} alt={employee.name} className="avatar-image" style={{ opacity: hasShift && hasValidShifts ? 1 : 0.5 }} /> : employee.name.charAt(0)}
        </div>
        <div className="staff-info">
          <div className="staff-name" style={{ color: hasShift && hasValidShifts ? 'inherit' : '#9ca3af' }}>{employee.name}</div>
          <div className="staff-position" style={{ color: hasShift && hasValidShifts ? 'inherit' : '#9ca3af' }}>{employee.position}</div>
        </div>
      </div>

      <div className="time-slots-column" style={{ position: 'relative' }}>
        {timeSlots.map((slot, index) => {
          // compute slot minute range (grid interval based on slot label)
          const [slotH, slotM] = slot.split(':').map(Number);
          const slotStartMin = slotH * 60 + (slotM || 0);
          const slotEndMin = slotStartMin + slotInterval;

          const slotKey = `${dayKey}_${slot}`;
          const unavailableReason = isTimeSlotUnavailable(employee.id, slot);

          // whether slot is within at least one defined shift segment
          const isWithinShift = hasShift && hasValidShifts && shiftHours.some(shift => {
            const [sH, sM] = shift.startTime.split(':').map(Number);
            const [eH, eM] = shift.endTime.split(':').map(Number);
            let shiftStart = sH * 60 + (sM || 0);
            let shiftEnd = eH * 60 + (eM || 0);
            if (shiftEnd <= shiftStart) shiftEnd += 24 * 60;
            // handle slot possibly being past midnight (rare)
            let sMin = slotStartMin;
            if (sMin < shiftStart && shiftEnd > 24 * 60) sMin += 24 * 60;
            return sMin >= shiftStart && sMin < shiftEnd;
          });

          // precise overlapped check
          const isCoveredByAppointment = slotIsOverlapped(slotStartMin, slotEndMin);

          return (
            <div key={slot} className="time-slot-wrapper" style={{ height: `${timeSlotHeightPx}px`, position: 'relative' }}>
              <div
                className={`time-slot ${(!hasShift || !hasValidShifts ? 'no-shift' : (!isWithinShift ? 'outside-shift' : (unavailableReason ? 'unavailable' : 'empty')) )}`}
                onClick={hasShift && hasValidShifts && isWithinShift && !isCoveredByAppointment ? () => handleTimeSlotClick(employee.id, slot, currentDate) : undefined}
                onMouseEnter={(e) => !isCoveredByAppointment && showTimeHoverHandler(e, slot)}
                onMouseLeave={hideTimeHover}
                style={{
                  cursor: (hasShift && hasValidShifts && isWithinShift && !isCoveredByAppointment) ? 'pointer' : 'not-allowed',
                  opacity: (!hasShift || !hasValidShifts || !isWithinShift) ? 0.35 : 1,
                  backgroundColor: (!hasShift || !hasValidShifts) ? '#f3f4f6' : (!isWithinShift ? '#fafafa' : '#ffffff'),
                  position: 'absolute',
                  left: 0,
                  right: 0,
                  top: 0
                }}>
                {/* If this slot is overlapped by an appointment, draw a subtle overlay bar (minute-accurate) instead of hiding the whole row */}
                {isCoveredByAppointment && (
                  <div
                    aria-hidden
                    style={{
                      position: 'absolute',
                      inset: 0,
                      background: 'linear-gradient(90deg, rgba(0,0,0,0.04), rgba(0,0,0,0.02))',
                      pointerEvents: 'none'
                    }}
                  />
                )}

                {unavailableReason && isWithinShift && (
                  <div className="unavailable-text">{unavailableReason.includes("Day Off") ? "DAY OFF" : "UNAVAIL"}</div>
                )}
              </div>
            </div>
          );
        })}

        {/* Appointment blocks rendered using minute-accurate top/height */}
        {appointmentBlocks.map((block, i) => (
          <div
            key={`block-${i}`}
            className="appointment-block fresha-style"
            style={{
              position: 'absolute',
              top: `${block.topPx}px`,
              left: '4px',
              right: '4px',
              height: `${block.heightPx}px`,
              backgroundColor: getAppointmentColorByStatus(block.appointment.status, block.appointment.color),
              borderRadius: '10px',
              padding: '8px 10px',
              boxShadow: '0 4px 10px rgba(0,0,0,0.12)',
              zIndex: 10,
              overflow: 'hidden',
              cursor: 'pointer'
            }}
            onClick={() => {
              const appointmentDetails = {
                ...block.appointment,
                employeeId: employee.id,
                employeeName: employee.name,
                slotTime: block.appointment.startTime || '',
                date: dayKey,
                slotKey: `${dayKey}_${block.appointment.startTime || ''}`
              };
              setSelectedBookingForStatus(appointmentDetails);
              setShowBookingStatusModal(true);
            }}
            onMouseEnter={(e) => showBookingTooltipHandler(e, {
              client: block.appointment.client,
              service: block.appointment.service,
              time: block.appointment.startTime,
              professional: employee.name,
              status: block.appointment.status || 'Confirmed',
              notes: block.appointment.notes
            })}
            onMouseLeave={hideBookingTooltip}
          >
            <div style={{ fontWeight: 700, color: '#fff', fontSize: 13 }}>{block.appointment.client}</div>
            <div style={{ color: 'rgba(255,255,255,0.95)', fontSize: 12 }}>{block.appointment.service}</div>
            <div style={{ color: 'rgba(255,255,255,0.85)', fontSize: 11, marginTop: 6 }}>
              {block.appointment.startTime || ''} {block.appointment.endTime ? `— ${block.appointment.endTime}` : ''}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

const WeekDayColumn = ({ day, employees, timeSlots, appointments, isTimeSlotUnavailable, handleTimeSlotClick, onShowMoreAppointments, showBookingTooltipHandler, hideBookingTooltip }) => {
  const dayKey = day.toISOString().split('T')[0];
  const isToday = day.toDateString() === new Date().toDateString();

  // Get all appointments for this day from all employees (similar to month view)
  const dayAppointments = [];

  employees.forEach(emp => {
    if (appointments[emp.id]) {
      Object.entries(appointments[emp.id]).forEach(([slotKey, appointment]) => {
        // Check if the appointment is for this day
        if (slotKey.startsWith(dayKey) || appointment.date === dayKey) {
          // Extract time from slot key (format: YYYY-MM-DD_HH:MM)
          const timeFromKey = slotKey.includes('_') ? slotKey.split('_')[1] : null;
          dayAppointments.push({
            ...appointment,
            time: timeFromKey ? formatTime(timeFromKey) : 'Time TBD',
            slotKey,
            timeSlot: timeFromKey,

          });
        }
      });
    }
  });

  return (
    <div key={dayKey} className="week-day-column">
      <div className={`week-day-header ${isToday ? 'is-today' : ''}`}>
        <span className="weekday-name">{day.toLocaleDateString('en-US', { weekday: 'short' })}</span>
        <span className="day-number">{day.getDate()}</span>
      </div>
      <div className="week-appointments">
        {dayAppointments.length > 0 ? (
          <>
            {dayAppointments.slice(0, 3).map((app, index) => (
              <div key={index}
                className="week-appointment-entry"
                style={{ backgroundColor: app.color }}
                onMouseEnter={(e) => showBookingTooltipHandler(e, {
                  client: app.client,
                  service: app.service,
                  time: app.time,
                  professional: app.employeeName,
                  status: app.status || 'Confirmed',
                  notes: app.notes
                })}
                onMouseLeave={hideBookingTooltip}>
                <span className="appointment-client-name">{app.client}</span>
                <span className="appointment-service-name">{app.service}</span>
                <span className="appointment-time">{app.time}</span>
              </div>
            ))}
            {dayAppointments.length > 3 && (
              <div
                className="week-more-appointments"
                onClick={(event) => onShowMoreAppointments(dayAppointments, day, event)}
              >
                +{dayAppointments.length - 3} more
              </div>
            )}
          </>
        ) : (
          <div className="week-no-appointments">
            No appointments
          </div>
        )}
      </div>
    </div>
  );
};

export default SelectCalendar